# -*- coding: utf-8 -*-
"""M3_Actividad.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15muKkmkfTXnOfN4YK2i-S3SJ3GAbT_Jv

# **Actividad M3**
"""

#!pip3 install mesa

# Commented out IPython magic to ensure Python compatibility.
# La clase `Model` se hace cargo de los atributos a nivel del modelo, maneja los agentes. 
# Cada modelo puede contener múltiples agentes y todos ellos son instancias de la clase `Agent`.
from mesa import Agent, Model 

# Con `SimultaneousActivation` hacemos que todos los agentes se activen de manera simultanea.
from mesa.time import SimultaneousActivation

# Vamos a hacer uso de `DataCollector` para obtener el grid completo cada paso (o generación) y lo usaremos para graficarlo.
from mesa.datacollection import DataCollector

# mathplotlib lo usamos para graficar/visualizar como evoluciona el autómata celular.
# %matplotlib inline
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
plt.rcParams["animation.html"] = "jshtml"
matplotlib.rcParams['animation.embed_limit'] = 2**128

# Definimos los siguientes paquetes para manejar valores númericos.
import numpy as np
import pandas as pd
from http.server import BaseHTTPRequestHandler, HTTPServer
import logging
import json
from vector import Vector

# Definimos otros paquetes que vamos a usar para medir el tiempo de ejecución de nuestro algoritmo.
import time
import datetime

width         = 0
height        = 0
things        = []
trafficlights = []
waitinglist = []
turno = 0
count = 0
def get_grid(model):
    '''
    Esta es una función auxiliar que nos permite guardar el grid para cada uno de los agentes.
    param model: El modelo del cual optener el grid.
    return una matriz con la información del grid del agente.
    '''
    grid = np.zeros((model.grid.width, model.grid.height))
    grid[0][0] = 4
    for cell in model.grid.coord_iter():
        cell_content, x, y = cell
        if cell_content:
          grid[x][y] = cell_content.live
    return grid

def get_gridById(model):
    '''
    Esta es una función auxiliar que nos permite guardar el grid para cada uno de los agentes.
    param model: El modelo del cual optener el grid.
    return una matriz con la información del grid del agente.
    '''
    grid = np.zeros((model.grid.width, model.grid.height))
    grid[0][0] = 4
    for cell in model.grid.coord_iter():
        cell_content, x, y = cell
        if isinstance(cell_content, Car):
          grid[x][y] = cell_content.unique_id
        elif cell_content:
          grid[x][y] = cell_content.live

    return grid

class Car(Agent):
  def __init__(self, unique_id,y,x,model):
    super().__init__(unique_id, model)
    self.unique_id = unique_id
    self.live = 4 #Si esta vivo o no (esta en el grid o no)
    self.crossed = False
    self.turn = np.random.choice(2)
    self.diff_x = x
    self.diff_y = y

  def send_pos():
    '''
    aqui se enviaría la posición del semaforo en formato JSON a unity
    '''
    return pos;

  def send_state():
    '''
    aqui se enviaría la posición del semaforo en formato JSON a unity
    '''
    return state;

  def move(self):
    neighbors  = self.model.grid.get_neighbors(self.pos, False, include_center = False)
    for neighbor in neighbors:
      if isinstance(neighbor,Traffic_Light) and not self.crossed:
        neighbor.waitingCar = True

        if neighbor.live == 1:
          self.crossed = True
          break
        else:
          return False
      elif isinstance(neighbor,Car) and neighbor.pos == (self.pos[0]+self.diff_y, self.pos[1]+self.diff_x):
        return False

    self.model.grid.move_agent(self,(self.pos[0] + self.diff_y, self.pos[1] + self.diff_x))
    return True
  
  def make_turn(self):
    if self.diff_x == 1:
      self.diff_x = 0
      self.diff_y = 1
    elif self.diff_x == -1:
      self.diff_x = 0
      self.diff_y = -1
    elif self.diff_y == 1:
      self.diff_x = -1
      self.diff_y = 0
    elif self.diff_y == -1:
      self.diff_x = 1
      self.diff_y = 0

    self.turn = False

    
  def step(self):
    if self.live > 0:
        self.move()
        if self.crossed and self.turn:
          self.make_turn()
    diccionary={'tag':'Car','posx':self.pos[1],'posz':self.pos[0],'lights':0,'reference':self.unique_id}
    things.append(diccionary)
       
  def advance(self):
       bounds = [(int(height/2),width-1), 
                  (height-1, int(width/2)-1),
                  (0, int(width/2)),
                  (int(height/2)-1,0)]
       for i in bounds:
          if self.pos == i:
            self.model.grid.remove_agent(self)
            self.model.schedule.remove(self)
            self.live = 0
          # self.remove(self)


    
def orden():
  global trafficlights, waitinglist, turno, count
  if count > 7 and count <10:
    if turno == 1:
      
        trafficlights[0].live = 2
        trafficlights[1].live = 3
        trafficlights[2].live = 2
        trafficlights[3].live = 3
        
    elif turno == 2:
        trafficlights[0].live = 3
        trafficlights[1].live = 2
        trafficlights[2].live = 3
        trafficlights[3].live = 2
      
    
  
  elif count > 10:
    if turno == 0:
      if trafficlights[1].waitingCar == True or trafficlights[3].waitingCar == True:
        trafficlights[0].live = 3
        trafficlights[1].live = 1
        trafficlights[2].live = 3
        trafficlights[3].live = 1
        turno = 2
      elif trafficlights[0].waitingCar == True or trafficlights[2].waitingCar == True:
        trafficlights[0].live = 1
        trafficlights[1].live = 3
        trafficlights[2].live = 1
        trafficlights[3].live = 3
        turno = 1
    elif turno == 1:
      if trafficlights[1].waitingCar == True or trafficlights[3].waitingCar == True:
        trafficlights[0].live = 3
        trafficlights[1].live = 1
        trafficlights[2].live = 3
        trafficlights[3].live = 1
        turno = 2
    elif turno == 2:
      if trafficlights[0].waitingCar == True or trafficlights[2].waitingCar == True:
        trafficlights[0].live = 1
        trafficlights[1].live = 3
        trafficlights[2].live = 1
        trafficlights[3].live = 3
        turno = 1
    count = 0
    
 
  count+=1    


class Traffic_Light(Agent):
    '''
    Representa a un agente o una celda con estado vivo (1) o muerto (0)
    '''
    def __init__(self, unique_id, pos, model):
        '''
        Crea un agente con estado inicial aleatorio de 0 o 1, también se le asigna un identificador 
        formado por una tupla (x,y). También se define un nuevo estado cuyo valor será definido por las 
        reglas mencionadas arriba.
        '''
        super().__init__(unique_id, model)
        self.live = 2
        self.waitingCar = False
        # self.light_state = light_state
        self.pos=pos
        # self.next_state = None
    def queue(self):
      self.waitingCar = 1
 
      

    
      
        #this_cell = self.model.grid.get_cell_list_contents([self.pos]) #la pongo porque por el momento no hace nada

from mesa import Model
from mesa.space import SingleGrid, MultiGrid
from mesa.datacollection import DataCollector
cont = 10
def spawn_Car(self):
        global cont
        rand = np.random.choice(3)

        pos = [(int((self.width/2)), 0),(int((self.width/2)-1), self.height-1),(0, int((self.height/2)-1)),(self.width-1, int((self.height/2)))]

        for i in pos:
          if self.grid.get_cell_list_contents([i]):
            return 0

        if rand == 0:
          new_car = Car(cont,0,1,self)
          self.grid.place_agent(new_car, pos[0])
        elif rand == 1:
          new_car = Car(cont,0,-1,self)
          self.grid.place_agent(new_car, pos[1])
        elif rand == 2:
          new_car = Car(cont,1,0,self)
          self.grid.place_agent(new_car, pos[2])
        elif rand == 3:
          new_car = Car(cont,-1,0,self)
          self.grid.place_agent(new_car, pos[3])
        self.schedule.add(new_car)      
        cont+=1
cont2 = 0
count3 = 0
class IntersectionModel(Model):
   
    def __init__(self, width, height, initial_cars):
        self.initial_trafficLight=4
        self.initial_cars=initial_cars
        self.grid = SingleGrid(width, height, True)
        self.schedule = SimultaneousActivation(self)
        self.width = width
        self.height = height

        #spawn Semaforos
        global trafficlights

        tl1 = Traffic_Light(1,(int((width/2)-2), (int(height/2)+1)), self)
        self.grid.place_agent(tl1, (int((width/2)-2), int((height/2)+1)))
        self.schedule.add(tl1)
        trafficlights.append(tl1)

        tl2 = Traffic_Light(2,(int((width/2)+1), int((height/2)+1)), self)
        self.grid.place_agent(tl2, (int((width/2)+1), int((height/2)+1)))
        self.schedule.add(tl2)
        trafficlights.append(tl2)

        tl3 = Traffic_Light(3,(int((width/2)+1), int((height/2)-2)), self)
        self.grid.place_agent(tl3, (int((width/2)+1), int((height/2)-2)))
        self.schedule.add(tl3)
        trafficlights.append(tl3)

        tl4 = Traffic_Light(4,(int((width/2)-2), int((height/2)-2)), self)
        self.grid.place_agent(tl4, (int((width/2)-2), int((height/2)-2)))
        self.schedule.add(tl4)
        trafficlights.append(tl4)

        '''
        tl1 = Traffic_Light(1,(1,1), 1, 1, self)
        self.grid.place_agent(tl1, (1,1))
        self.schedule.add(tl1)

        tl2 = Traffic_Light(2,(2,2), 1, 1, self)
        self.grid.place_agent(tl2, (2,2))
        self.schedule.add(tl2)

        tl3 = Traffic_Light(3,(3,3), 1, 1, self)
        self.grid.place_agent(tl3, (3,3))
        self.schedule.add(tl3)

        tl4 = Traffic_Light(4,(4,4), 1, 1, self)
        self.grid.place_agent(tl4, (4,4))
        self.schedule.add(tl4)'''

        #spawn_Car(self)
          
        # Aquí definimos con colector para obtener el grid completo.
        #self.datacollector = DataCollector(
        #    model_reporters={"Grid": get_grid})
        
        self.datacollector = DataCollector(
            model_reporters={"Grid": get_gridById})
        
    #spawn Carros (esto debería ser una función)
    
   
  
    def step(self):
       
        self.datacollector.collect(self)
        self.schedule.step()
        global cont2
        global count3
        if count3==3:
          spawn_Car(self)
          count3 = 0
        else: 
          count3+=1
        orden()

initial_cars        = 5 #Numero de Agentes
w                   = 10 #M
h                   = 10 #N

model = IntersectionModel(w, h, initial_cars)

def updateThings():
    global model
    global things

    things.clear()
    model.step()

    return things

def infoToJSON(ps):
    infoDict=[]
    for tModel in things:
        thing={
            "x" : tModel['posx'],
            "z" : tModel['posz'],
            "tag" : tModel['tag'],
            "lights" : tModel['lights'],
            "reference" : tModel['reference']
        }
        infoDict.append(tModel)
    return json.dumps(infoDict)

class Server(BaseHTTPRequestHandler):

    def _set_response(self):
        self.send_response(200)
        self.send_header('Content-type', 'text/html')
        self.end_headers()

    def do_GET(self):
        logging.info("GET request,\nPath: %s\nHeaders:\n%s\n", str(self.path), str(self.headers))
        self._set_response()
        self.wfile.write("GET request for {}".format(self.path).encode('utf-8'))

    def do_POST(self):
        content_length = int(self.headers['Content-Length'])
        #post_data = self.rfile.read(content_length)
        post_data = json.loads(self.rfile.read(content_length))
        #logging.info("POST request,\nPath: %s\nHeaders:\n%s\n\nBody:\n%s\n",
                     #str(self.path), str(self.headers), post_data.decode('utf-8'))
        logging.info("POST request,\nPath: %s\nHeaders:\n%s\n\nBody:\n%s\n",
                     str(self.path), str(self.headers), json.dumps(post_data))

        '''
        x = post_data['x'] * 2
        y = post_data['y'] * 2
        z = post_data['z'] * 2

        position = {
            "x" : x,
            "y" : y,
            "z" : z
        }

        self._set_response()
        #self.wfile.write("POST request for {}".format(self.path).encode('utf-8'))
        self.wfile.write(str(position).encode('utf-8'))
        '''

        info = updateThings()
        #print(positions)
        self._set_response()
        print(infoToJSON(info))
        resp = "{\"data\":" +  infoToJSON(info) + "}"
        #print(resp)
        self.wfile.write(resp.encode('utf-8'))

def run(server_class=HTTPServer, handler_class=Server, port=8585):
    logging.basicConfig(level=logging.INFO)
    server_address = ('', port)
    httpd = server_class(server_address, handler_class)
    logging.info("Starting httpd...\n") # HTTPD is HTTP Daemon!
    print("hola4")
    try:
        print("hola1")
        httpd.serve_forever()
        print("hasdadsd")
    except KeyboardInterrupt:   # CTRL+C stops the server
        print("hola5")
        pass
    httpd.server_close()
    logging.info("Stopping httpd...\n")

if __name__ == '__main__':
    from sys import argv

    if len(argv) == 2:
        run(port=int(argv[1]))
    else:
        run()
